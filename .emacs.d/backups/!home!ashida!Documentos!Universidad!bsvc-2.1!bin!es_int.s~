* Inicializa el SP y el PC
**************************
        ORG     $0
        DC.L    $8000           * Pila
        DC.L    PRUEBA19        * PC
        ORG     $400
* Faltan las pruebas 11,13,14,15 *
* Definición de equivalencias
*********************************
*A*
MR1A    EQU     $effc01         * de modo A (escritura)
MR2A    EQU     $effc01         * de modo A (2º escritura)
SRA     EQU     $effc03         * de estado A (lectura)
CSRA    EQU     $effc03         * de seleccion de reloj A (escritura)
CRA     EQU     $effc05         * de control A (escritura)
TBA     EQU     $effc07         * buffer transmision A (escritura)
RBA     EQU     $effc07         * buffer recepcion A  (lectura)
*B*
MR1B    EQU     $effc11         * de modo B (escritura)
MR2B    EQU     $effc11         * de modo B (2º escritura)
SRB     EQU     $effc13         * de estado B (lectura)
CSRB    EQU     $effc13         * de seleccion de reloj B (escritura)
CRB     EQU     $effc15         * de control B (escritura)
TBB     EQU     $effc17         * buffer transmision B (escritura)
RBB     EQU     $effc17         * buffer recepcion B (lectura)
*AMBAS*
IVR     EQU     $effc19         * vector de interrupcion
ACR	EQU	$effc09	        * de control auxiliar
IMR     EQU     $effc0B         * de mascara de interrupcion  (escritura)
ISR     EQU     $effc0B         * de estado de interrupcion  (lectura)
*VARIABLES*

T_BUF   EQU     2001            * tamaño del buffer
        
PUNTEA: DS.L	1		* punteros de escritura de A
BUFFERA: DS.B   T_BUF           * buffer interno escritura A

PUNTEB: DS.L	1		* punteros de escritura de B
BUFFERB: DS.B   T_BUF           * buffer interno escritura B

PUNTLA: DS.L	1		* punteros de lectura de A
BUFFERAL:DS.B   T_BUF           * buffer interno lectura A

PUNTLB: DS.L	1		* punteros de lectura de B
BUFFERBL:DS.B   T_BUF           * buffer interno lectura B
        
FLAGS:  DS.w    1               * reservamos espacio para el flag de salto de linea [01 -> A, 11 -> B]
FLAGR:  DS.W    1               * reservamos espacio para el flag el retorno de carro [01 -> A, 11 -> B]

CPIMR:  DS.B    1               * Para copia de IMR
        
*CRA Y CRB PRIMER BYTE: SI ES A(0) O B(1)
*CRA Y CRB SEGUNDO BYTE: SI ES RECEPCION(0) O TRANSMISION(1)
*csra Y CSRB 4 PRIMEROS VEL DE TRANSMISION, 4 ULTIMOS VEL DE RECEPCION
*PUNTA:  LEA     BUFFERA,A5      * A5 <- puntero a bufferA
*Tener en cuenta las operaciones con la instruccion .L ya que las divide en dos	
* IMR tener una copia siempre porque no podemos leerla nunca. ( Ternerlo en cuenta en concurrencia )      

**************************** INIT *************************************************************
INIT:   LINK            A6,#0
        MOVE.B          #%00010000,CRA          * Reinicia el puntero MR1
        MOVE.B          #%00000011,MR1A         * 8 bits por caracter.
        MOVE.B          #%00000000,MR2A         * Eco desactivado.
        MOVE.B          #%11001100,CSRA         * Velocidad = 38400 bps.
        MOVE.B          #%00000000,ACR          * Velocidad = 38400 bps.
        MOVE.B		#%00000101,CRA          * Transmision y recepcion activados.
        MOVE.B          #%00010000,CRB          * Reinicia el puntero MR1
        MOVE.B          #%00000011,MR1B         * 8 bits por caracter.
        MOVE.B          #%00000000,MR2B         * Eco desactivado.
        MOVE.B          #%11001100,CSRB         * Velocidad = 38400 bps.
        MOVE.B		#%00000101,CRB          * Transmision y recepcion activados.
        MOVE.B          #$40,IVR                * Vector de interrupción 40.
        MOVE.L          #RTI,$100               * Salto a la rutina de tratamiento de interrupcion
        MOVE.B          #%00100010,CPIMR
        MOVE.B          CPIMR,IMR
        LEA		PUNTLA,A4		* Cargamos el puntero memoria
        MOVE.W		#0,A4			* Inicializamos el puntero de lectura
        MOVE.W		#0,2(A4)		* Inicializamos el puntero de escritura
        LEA		PUNTLB,A4		* Cargamos el puntero memoria
        MOVE.W		#0,A4			* Inicializamos el puntero de lectura
        MOVE.W		#0,2(A4)		* Inicializamos el puntero de escritura
        LEA		PUNTEA,A4		* Cargamos el puntero memoria
        MOVE.W		#0,A4			* Inicializamos el puntero de lectura
        MOVE.W		#0,2(A4)		* Inicializamos el puntero de escritura
        LEA		PUNTEB,A4		* Cargamos el puntero memoria
        MOVE.W		#0,A4			* Inicializamos el puntero de lectura
        MOVE.W		#0,2(A4)		* Inicializamos el puntero de escritura
        LEA             FLAGS,A4
        MOVE.L          #-1,A4
        UNLK            A6
        RTS
**************************** LINEA ***********************************************************
LINEA:  LINK            A6,#0           * MARCO DE PILA
        BTST            #0,D0		* Comparamos el primer bit del buffer pasado por parametro de entrada
        BNE             LINB		* Comparamos que el primer bit sea distinto de 0
        BTST		#1,D0		* Comparamos el segundo bit del buffer pasado por parametro de entrada
        BNE		LINTA		* Comparamos que el segundo bit sea distinto de 0
        LEA		BUFFERAL,A5	* Cargamos el buffer de lectura de A
        LEA		PUNTLA,A4	* Cargamos los punteros de lectura de A
        BRA		SECLIN
LINB:	BTST            #1,D0		* Comparamos el segundo bit del buffer pasado por parametro de entrada
        BNE             LINTB		* Comparamos que el segundo bit sea distinto de 0
        LEA		BUFFERBL,A5	* Cargamos el buffer de lectura de B
        LEA		PUNTLB,A4	* Cargamos los punteros de lectura de B
        BRA		SECLIN
LINTA:	LEA		BUFFERA,A5	* Cargamos el buffer de escritura de A
        LEA		PUNTEA,A4	* Cargamos los punteros de escritura de A
        BRA		SECLIN
LINTB:	LEA		BUFFERB,A5	* Cargamos el buffer de escritura de B
        LEA		PUNTEB,A4	* Cargamos los punteros de escritura de B
        BRA		SECLIN
SECLIN:	MOVE.W		(A4),D2		* Cargamos el puntero de lectura
        MOVE.W          2(A4),D3        * Cargamos el puntero de escritura
        CMP.W           D2,D3           * Si no hay para leer 
        BEQ             FINLIN2         * Sale de linea con 0 en D0
        MOVE.L		#0,D5		* Inicializamos el contador de caracteres a 0
BUCLIN: MOVE.B          (A5,D2),D0      * Guardamos en D0 el caracter leido
        CMP.W           #13,D0          * Comprobamos si es salto de linea
        BEQ             FINLIN          * Saltamos a fin
        ADD.W           #1,D2           * Avanzamos puntero
        ADD.L           #1,D5           * cont++
        CMP.L           #2000,D5        * Comprobamos si hemos vaciado el buffer y no hemos encontrado CR
        BEQ             FINLIN2         * Saltamos a otro fin
        CMP.W           #2000,D2        * Comprobamos si hemos llegado al final.
        BEQ             RESLIN          * Reseteamos el puntero
        BRA             BUCLIN
FINLIN: ADD.L           #1,D5           * Sumamos el CR
        ADD.W           #1,D2           * Avanzamos puntero
        MOVE.L          D5,D0           * Devolvemos en D0
        UNLK            A6
        RTS
FINLIN2:MOVE.L          #0,D0           * 0 a D0 porque no hay CR
        UNLK            A6
        RTS
RESLIN: MOVE.W          #0,D2           * Lectura al principio del buffer again
        BRA             BUCLIN
**************************** FIN DE LINEA *****************************************************
**************************** PRINT ************************************************************
PRINT:  LINK    A6,#0           * MARCO DE PILA
        MOVE.L  8(A6),A3        * buffer interno
        MOVE.W  12(A6),A4       * buffer circular
        MOVE.W  14(A6),D5       * tamaño
        CMP.W   #0,D5
        BEQ     ERPRINT
        MOVE.L  #0,D6           * contador
        CMP.W   #%0000,A4       * comprobamos si es A
        BEQ     PERA
        CMP.W   #%0001,A4       * comprobamos si es B
        BEQ     PERB
        BRA     ERPRINT
PERA:   MOVE.L  #%00000010,D0   * cargamos el buffer circular de transmision A
BPERA:  MOVE.B  (A3)+,D1        * cargamos el valor del buffer interno a D1 
        CMP.B   #13,D1          * comprobamos si es un retorno de carro
        BNE     BPERA1
        MOVE.W  #%0001,FLAGR    * activamos el flag de retorno de carro del periferico A   
BPERA1: BSR     ESCCAR
        CMP     #-1,D0          * comprobamos que no haya habido ningun error
        BEQ     FINPRINT        * si ha habido algun error salimos
        CMP.W   #%0001,FLAGR    * comparamos que no este activado el flag de retorno de carro del periferico A
        BNE     BPERA2
        MOVE.W  #$2700,SR       
        MOVE.B  #%00000001,CPIMR
        MOVE.B  CPIMR,IMR
        MOVE.W  #$2000,SR
BPERA2: ADD.L   #1,D6
        CMP     D5,D6
        BNE     PERA
        BRA     FINPRINT
PERB:   MOVE.L  #%00000011,D0   * cargamos el buffer circular de transmision B
BPERB:  MOVE.B  (A3)+,D1        * cargamos el valor del buffer interno a D1 
        CMP.B   #13,D1          * comprobamos si es un retorno de carro
        BNE     BPERB1
        MOVE.W  #%0011,FLAGR    * activamos el flag de retorno de carro del periferico B
BPERB1: BSR     ESCCAR
        CMP     #-1,D0          * comprobamos que no haya habido ningun error
        BEQ     FINPRINT        * Si ha habido algun error salimos
        CMP.W   #%0011,FLAGR    * comparamos que no este activado el flag de retorno de carro del periferico B
        BNE     BPERB2
        MOVE.W  #$2700,SR
        MOVE.B  #%00010000,CPIMR
        MOVE.B  CPIMR,IMR
        MOVE.W  #$2000,SR
BPERB2: ADD.L   #1,D6
        CMP     D5,D6
        BNE     PERB
FINPRINT:MOVE.L D6,D5
        MOVE.L  D5,D0
        UNLK    A6
        RTS
ERPRINT:MOVE.L #-1,D0
        UNLK    A6
        RTS
**************************** FIN DE PRINT *****************************************************
**************************** RTI **************************************************************
RTI:    LINK            A6,#0
        MOVE.B          (ISR),D2           
        AND.B           (CPIMR),D2
        BTST            #0,D2
        BNE             TxRDYA
        BTST            #1,D2
        BNE             RxRDYA
        BTST            #4,D2
        BNE             TxRDYB
        BTST            #5,D2
        BNE             RxRDYB
        BRA             FINRTI
TxRDYA: CMP.W           #%0000,FLAGS
        BNE             TFA
        MOVE.L          #%00000010,D0
        BSR             LEECAR
        CMP.L           #-1,D0
        BEQ             ERR_TA
        CMP.B           #13,D0
        BEQ             SLA 
IMPA:   MOVE.B          D0,TBA
        BRA             FINRTI
SLA:    MOVE.W          #%0001,FLAGS
        BRA             IMPA
RxRDYA: MOVE.B          (RBA),D1
        MOVE.L          #%00000000,D0
        BSR             ESCCAR
        CMP.L           #-1,D0
        BNE             FINRTI
        MOVE.L          #0,D1
        BRA             FINRTI
TxRDYB: CMP.W           #%0000,FLAGS
        BNE             TFB
        MOVE.L          #%00000011,D0
        BSR             LEECAR
        CMP.L           #-1,D0
        BEQ             ERR_TB
        CMP.B           #13,D0
        BEQ             SLB
IMPB:   MOVE.B          D0,TBB
        BRA             FINRTI
SLB:    MOVE.W          #%0011,FLAGS
        BRA             IMPB
RxRDYB: MOVE.B          (RBB),D1
        MOVE.L          #%000000001,D0
        BSR             ESCCAR
        CMP.L           #-1,D0
        BNE             FINRTI
        MOVE.L          #0,D1
FINRTI: UNLK            A6
        RTE
ERR_TA: AND.B           #%11111110,CPIMR
        MOVE.B          CPIMR,IMR
        BRA             FINRTI
ERR_TB: AND.B           #%11101111,CPIMR
        MOVE.B          CPIMR,IMR
        BRA             FINRTI
TFA:    MOVE.B          #10,TBA
        MOVE.W          #%0000,FLAGR
        MOVE.W          #%0000,FLAGS
	MOVE.W		#%000000010,D0
	BSR		LINEA
	CMP.L		#0,D0
	BNE		FINRTI
        BRA             ERR_TA
TFB:    MOVE.B 		#10,TBB
        MOVE.W          #%0000,FLAGR
        MOVE.W          #%0000,FLAGS
	MOVE.W		#%000000011,D0
	BSR		LINEA
	CMP.L		#0,D0
	BNE		FINRTI
        BRA             ERR_TB
**************************** FIN DE RTI *******************************************************
**************************** SCAN *************************************************************
SCAN:   LINK            A6,#0   	* MARCO DE PILA
        MOVE.L          8(A6),A3        * buffer interno
        MOVE.W          12(A6),A4        * descriptor, buffer circular donde se realiza la lectura (0 = A, 1 = B, X [cualquier otro] = error)
        MOVE.W          14(A6),D5        * tamaño
        CMP.L           #0,D5
        BEQ             ERSCAN
        CMP.L           #%00000000,A4
        BEQ             SPA
        CMP.L           #%00000001,A4
        BEQ             SPB
        BRA             ERSCAN
SPA:    MOVE.L          #%00000000,D0
        BSR             LINEA
        CMP             #0,D0
        BEQ             SCAN0
        CMP             D0,D5
        BLT             SCAN0
        MOVE.L          D0,D5
        MOVE.L          D0,D3
BSPA:   MOVE.L          #%00000000,D0
        BSR             LEECAR
        MOVE.B          D0,(A3)+
        SUB.L           #1,D3
        CMP             #0,D3
        BNE             BSPA
        BRA             SALSCAN
SPB:    MOVE.L          #%00000001,D0
        BSR             LINEA
        CMP             #0,D0
        BEQ             SCAN0
        CMP             D0,D5
        BLT             SCAN0
        MOVE.L          D0,D5
        MOVE.L          D0,D3
BSPB:   MOVE.L          #%00000001,D0        
        BSR             LEECAR
        MOVE.B          D0,(A3)+
        SUB.L           #1,D3
        CMP             #0,D3
        BNE             BSPB
SALSCAN:MOVE.L          D5,D0
FINSCAN:UNLK          	A6
        RTS
ERSCAN: MOVE.L          #$FFFFFFFF,D0
        BRA             FINSCAN
SCAN0:  MOVE.L          #0,D0
        BRA             FINSCAN        
**************************** FIN SCAN *********************************************************
**************************** LEECAR ***********************************************************
LEECAR: BTST            #0,D0		* Comparamos el primer bit del buffer pasado por parametro de entrada
        BNE             LEEB		* Comparamos que el primer bit sea distinto de 0
        BTST		#1,D0		* Comparamos el segundo bit del buffer pasado por parametro de entrada
        BNE		TRANSA		* Comparamos que el segundo bit sea distinto de 0
        LEA		BUFFERAL,A5	* Cargamos el buffer de lectura de A
        LEA		PUNTLA,A4	* Cargamos los punteros de lectura de A
        BRA		SECLEE
LEEB:	BTST            #1,D0		* Comparamos el segundo bit del buffer pasado por parametro de entrada
        BNE             TRANSB		* Comparamos que el segundo bit sea distinto de 0
        LEA	        BUFFERBL,A5	* Cargamos el buffer de lectura de B
        LEA     	PUNTLB,A4	* Cargamos los punteros de lectura de B
        BRA		SECLEE
TRANSA: LEA		BUFFERA,A5	* Cargamos el buffer de escritura de A
        LEA	        PUNTEA,A4	* Cargamos los punteros de lectura de A
        BRA		SECLEE
TRANSB: LEA		BUFFERB,A5	* Cargamos el buffer de escritura de B
        LEA		PUNTEB,A4	* Cargamos los punteros de lectura de B
        BRA		SECLEE
SECLEE:	MOVE.W          (A4),D1		* Cargamos el puntero de lectura
        MOVE.W	        2(A4),D2	* Cargamos el puntero de la escritura
        CMP.W		D1,D2		* Comparamos los dos punteros en el buffer
        BEQ		LEEVAC  	* Si son iguales los punteros saltamos a LEELLENO
        MOVE.B		(A5,D1),D0	* Cargamos el dato que hemos leido
        ADD.W		#1,D1		* Avanzamos una posicion el puntero
        CMP.W		#2001,D1	* Miramos que no estemos al final del buffer circular,que no nos hayamos pasado de rosca
        BEQ		LEERST		* Reseteamos el puntero si el buffer esta lleno
        BRA		FINLEE
LEEVAC: MOVE.L          #$FFFFFFFF,D0	* En el caso en que hemos llegado al final no tenemos datos que leer
        RTS
LEERST:	MOVE.W          #0,D1		* Resetamos el contador del puntero a cero
        BRA		FINLEE
FINLEE: MOVE.W          D1,(A4)		* Actualizamos el puntero
        RTS
**************************** FIN DE LEECAR ****************************************************
**************************** ESCCAR ***********************************************************
ESCCAR: LINK            A6,#0           * MARCO DE PILA
        BTST            #0,D0		* Comparamos el primer bit del buffer pasado por parametro de entrada
        BNE             ESCB		* Comparamos que el primer bit sea distinto de 0
        BTST		#1,D0		* Comparamos el segundo bit del buffer pasado por parametro de entrada
        BNE		TRANA		* Comparamos que el segundo bit sea distinto de 0
        LEA		BUFFERAL,A5	* Cargamos el buffer de lectura de A
        LEA		PUNTLA,A4	* Cargamos los punteros de lectura de A
        BRA		SECESC
ESCB:   BTST            #1,D0		* Comparamos el segundo bit del buffer pasado por parametro de entrada
        BNE             TRANB		* Comparamos que el segundo bit sea distinto de 0
        LEA		BUFFERBL,A5	* Cargamos el buffer de lectura de B
        LEA		PUNTLB,A4	* Cargamos los punteros de lectura de B
        BRA		SECESC
TRANA:  LEA		BUFFERA,A5	* Cargamos el buffer de escritura de A
        LEA		PUNTEA,A4	* Cargamos los punteros de escritura de A
        BRA		SECESC
TRANB:  LEA		BUFFERB,A5	* Cargamos el buffer de escritura de B
        LEA		PUNTEB,A4	* Cargamos los punteros de escritura de B
SECESC: MOVE.W          (A4),D2	        * Cargamos el puntero de lectura
        MOVE.W	        2(A4),D3	* Cargamos el puntero de la escritura
        CMP.W           #0,D2           * Comprobamos lectura = 0
        BEQ             CE2K            * Comprobamos que el de escritura esté en 2k
        SUB.W           #1,D2           * Restamos 1 al puntero de lectura (por el espacio en blanco)
        CMP.W           D2,D3           * Miramos que no estemos al final del buffer circular,que no nos hayamos pasado de rosca
        BEQ             ESCLL           * Reseteamos si son iguales, el puntero de escritura
        CMP.W		#2001,D3        * miramos si el de escritura está al final
        BNE             ESCP
        MOVE.W          #0,D3
ESCP:   MOVE.B          D1,(A5,D3)      * Cargamos el dato que hemos leido
        ADD.W           #1,D3           * Avanzamos una posicion el puntero
        CMP.W           #2001,D3        * Comprobamos si el puntero a llegado al final
        BNE             FINESC          * Si no, salimos
	BTST		#1,D0		* Comparamos el segundo bit del buffer pasado por parametro de entrada
	BNE		FINESC
        MOVE.W          #0,D3
        BRA             FINESC
CE2K:   CMP.W           #2000,D3        * Comprobamo que el de escritura está en 2k
        BEQ             ESCLL           * Si es así, buffer lleno.
        BRA             ESCP             
FINESC: MOVE.L          #0,D0
        MOVE.W          D3,2(A4)	* Actualizamos el puntero
        UNLK          	A6
        RTS
ESCLL:  MOVE.L          #$FFFFFFFF,D0   * No se ha podido escribir
        UNLK          	A6
        RTS
**************************** FIN DE ESCCAR ****************************************************
*************************** PRUEBAS ***********************************************************

PRUEBA: BSR             INIT             * Inicia el controlador
        BREAK
        MOVE.L          #$00000000,D0    * Caso 5 prueba manual
        MOVE.L          #$0000002a,D1    * A en ASCII hexadecimal
        BSR             ESCCAR
        BREAK
        MOVE.L          #$00000000,D0   * Caso 5 prueba manual
        MOVE.L          #$b1,D1         * A en ASCII hexadecimal
        BSR             ESCCAR
        BREAK
        MOVE.L          #$00000000,D0   * Caso para leer el caso 5
        BSR             LEECAR
        BREAK
        MOVE.L          #$00000000,D0   * Caso para leer el caso 5
        BSR             LEECAR
        BREAK
        
* Pruebas Bastas
PRUEBA4:BSR             INIT
        MOVE.L          #0,D5
BUCPRU2:MOVE.L          #$00000000,D0    * Caso 5 prueba manual
        MOVE.L          #$0000002a,D1    * Caso 5 prueba manual
        BSR             ESCCAR
        ADD.B           #1,D5
        CMP             #2000,D5
        BNE             BUCPRU2
        MOVE.L          #$00000000,D0    * Caso 5 prueba manual
        BSR             LINEA
        BREAK

* Prueba 6 *
PRUEBA6:BSR             INIT             * Inicia el controlador
	MOVE.L		#0,D6
BB61:   MOVE.L          #$0000011,D0    * Caso 5 prueba manual
        MOVE.L          #$0000002a,D1    * A en ASCII hexadecimal
        BSR             ESCCAR
	ADD.L		#1,D6
	CMP		#2200,D6
	BNE		BB61
        BREAK

* Prueba 7 *
PRUEBA7:BSR             INIT             * Inicia el controlador
	MOVE.L          #$00000011,D0   * Caso para leer el caso 5
        BSR             LEECAR
        BREAK

* Prueba 11 *
PRUEBA11:BSR             INIT             * Inicia el controlador
	MOVE.L		#0,D6
BB111:  MOVE.L          #$0000011,D0    * Caso 5 prueba manual
        MOVE.L          #$0000002a,D1    * A en ASCII hexadecimal
        BSR             ESCCAR
	ADD.L		#1,D6
	CMP		#2000,D6
	BNE		BB111
	MOVE.L		#0,D6
BB112	MOVE.L          #$00000011,D0   * Caso para leer el caso 5
        BSR             LEECAR
	ADD.L		#1,D6
	CMP		#2000,D6
	BNE		BB112        
	BREAK

* Prueba 13 *
PRUEBA13:BSR             INIT             * Inicia el controlador
	MOVE.L		#0,D6
BB131:  MOVE.L          #$00000001,D0    * Caso 5 prueba manual
        MOVE.L          #$0000002a,D1    * A en ASCII hexadecimal
        BSR             ESCCAR
	ADD.L		#1,D6
	CMP		#2000,D6
	BNE		BB131
	MOVE.L          #$00000001,D0   * Caso para leer el caso 5
        BSR             LEECAR       
	MOVE.L		#0,D6
BB132:  MOVE.L          #$00000001,D0    * Caso 5 prueba manual
        MOVE.L          #$0000002a,D1    * A en ASCII hexadecimal
        BSR             ESCCAR
	ADD.L		#1,D6
	CMP		#2,D6
	BNE		BB132	
	BREAK

* Prueba 14 *
PRUEBA14:BSR             INIT             * Inicia el controlador
	MOVE.L		#0,D6
BB141:  MOVE.L          #$00000010,D0    * Caso 5 prueba manual
        MOVE.L          #$0000002a,D1    * A en ASCII hexadecimal
        BSR             ESCCAR
	ADD.L		#1,D6
	CMP		#2000,D6
	BNE		BB141
	MOVE.L		#0,D6
BB142:  MOVE.L          #$00000001,D0   * Caso para leer el caso 5
        BSR             LEECAR       
	ADD.L		#1,D6
	CMP		#10,D6
	BNE		BB142
	MOVE.L		#0,D6
BB143:  MOVE.L          #$00000010,D0    * Caso 5 prueba manual
        MOVE.L          #$0000002a,D1    * A en ASCII hexadecimal
        BSR             ESCCAR
	ADD.L		#1,D6
	CMP		#10,D6
	BNE		BB143	
	BREAK

* Prueba 15 *
PRUEBA15:BSR             INIT            * Inicia el controlador
	MOVE.L		#0,D6
        MOVE.L          #0,D1            * A en ASCII hexadecimal
BB151:  MOVE.L          #$00000011,D0    * Caso 5 prueba manual
        BSR             ESCCAR
	ADD.L		#1,D6
        ADD.L           #1,D1
        CMP             #9,D1
        BEQ             YEY
	CMP		#2000,D6
	BNE		BB151
        BREAK
	MOVE.L		#0,D6
BB152:  MOVE.L          #$00000011,D0    * Caso para leer el caso 5
        BSR             LEECAR       
	ADD.L		#1,D6
	CMP		#10,D6
	BNE		BB152
        BREAK
	MOVE.L		#0,D6
        MOVE.L          #0,D1
BB153:  MOVE.L          #$00000011,D0    * Caso 5 prueba manual
        BSR             ESCCAR
	ADD.L		#1,D6
        ADD.L           #1,D1
        CMP             #9,D1
        BEQ             YAY
	CMP		#10,D6
	BNE		BB153
	BREAK
	MOVE.L		#0,D6
BB154:  MOVE.L          #$00000011,D0   * Caso para leer el caso 5
        BSR             LEECAR       
	ADD.L		#1,D6
	CMP		#2000,D6
	BNE		BB154
	BREAK
YEY:    MOVE.L          #0,D1
        BRA             BB151
YAY:    MOVE.L          #0,D1
        BRA             BB153
        
PRUEBA16:BSR            INIT            * Inicia el controlador
	MOVE.L		#0,D6
BB161:  MOVE.L          #$00000011,D0    * Caso 5 prueba manual
        MOVE.L          #1,D1            * A en ASCII hexadecimal
        BSR             ESCCAR
	ADD.L		#1,D6
	CMP		#2000,D6
	BNE		BB161
        BREAK
	MOVE.L		#0,D6        
BB162:  MOVE.L          #$00000011,D0   * Caso para leer el caso 5
        BSR             LEECAR       
	ADD.L		#1,D6
	CMP		#10,D6
	BNE		BB162
	BREAK
	MOVE.L		#0,D6
BB163:  MOVE.L          #$00000011,D0    * Caso 5 prueba manual
        MOVE.L          #1,D1            * A en ASCII hexadecimal
        BSR             ESCCAR
	ADD.L		#1,D6
	CMP		#10,D6
	BNE		BB163
        BREAK
	MOVE.L		#0,D6        
BB164:  MOVE.L          #$00000011,D0   * Caso para leer el caso 5
        BSR             LEECAR       
	ADD.L		#1,D6
	CMP		#2000,D6
	BNE		BB164
	BREAK
        
CONTL: DC.W 0
CONTC: DC.W 0
DIRLEC: DC.L 0
DIRESC: DC.L 0
TAME: DC.W 0
DESA: EQU 1
DESB: EQU 0
NLIN: EQU 4
TAML: EQU 200
TAMB: EQU 5
BUFFER: DS.B 5000

BUS_ERROR:  BREAK
            NOP
ADDRESS_ER: BREAK
            NOP
ILLEGAL_IN: BREAK
            NOP
PRIV_VIOLT: BREAK
            NOP
PRUEBA17:
INICIO: MOVE.L #BUS_ERROR,8
        MOVE.L #ADDRESS_ER,12
        MOVE.L #ILLEGAL_IN,16
        MOVE.L #PRIV_VIOLT,32
        BSR INIT
        MOVE.W #$2000,SR
BUCPR1:  MOVE.W #0,CONTC
        MOVE.W #NLIN,CONTL
        MOVE.L #BUFFER,DIRLEC
OTRAL1:  MOVE.W #TAML,-(A7)
        MOVE.W #DESA,-(A7)
        MOVE.L DIRLEC,-(A7)
ESPL1:   BSR SCAN
        CMP.L #0,D0
        BEQ ESPL1
        ADD.L #8,A7
        ADD.L D0,DIRLEC
        ADD.W D0,CONTC
        SUB.W #1,CONTL
        BNE OTRAL1
        MOVE.L #BUFFER,DIRLEC
OTRAE1:  MOVE.W #TAMB,TAME
ESPE1:   MOVE.W TAME,-(A7)
        MOVE.W #DESB,-(A7)
        MOVE.L DIRLEC,-(A7)
        BSR PRINT
        ADD.L #8,A7 
        ADD.L D0,DIRLEC
        SUB.W D0,CONTC
        BEQ SALIR1
        SUB.W D0,TAME
        BNE ESPE1
        CMP.W #TAMB,CONTC
        BHI OTRAE1
        MOVE.W CONTC,TAME
        BRA ESPE1
SALIR1: BRA BUCPR1
FIN1:   BREAK

PRUEBA18:
        BSR     INIT
        MOVE.W  #$2000,SR
        BSR     PPRINT1
        MOVE.L  #9,D6
        BREAK

PPRINT1:
        MOVE.W #11,-(A7)
        MOVE.W #0,-(A7)
        MOVE.L #BUFFER,-(A7)
        MOVE.B #$31,BUFFER
        MOVE.B #$32,BUFFER+1
        MOVE.B #$33,BUFFER+2
        MOVE.B #$34,BUFFER+3
        MOVE.B #$35,BUFFER+4
        MOVE.B #$36,BUFFER+5
        MOVE.B #$37,BUFFER+6
        MOVE.B #$38,BUFFER+7
        MOVE.B #$39,BUFFER+8
        MOVE.B #$30,BUFFER+9
        MOVE.B #$0d,BUFFER+10
        BREAK
        BSR PRINT
        ADD.L  #8,D6
        BREAK
        RTS
PSCAN1:  MOVE.W #2000,-(A7)
        MOVE.W #0,-(A7)
        MOVE.L #BUFFER,-(A7)
        BREAK
        BSR SCAN
        ADD.L  #9,D6
        BREAK
        RTS


PRUEBA19:
        
    BSR INIT
    MOVE.W  #$2000,SR *habilitar       
    nop
    nop
    MOVE.L   #BUFFER,A1
    MOVE.B   #0,D3

    MOVE.L   #0,D2
    MOVE.L   #3,D5    
BUC2: 
    MOVE.L   #100,D6
BUC1: 
   
    MOVE.B   #$31,(A1)+
    MOVE.B   #$32,(A1)+
    MOVE.B   #$33,(A1)+
    MOVE.B   #$34,(A1)+
    MOVE.B   #$35,(A1)+
    MOVE.B   #$36,(A1)+
    MOVE.B   #$37,(A1)+
    MOVE.B   #$38,(A1)+
    MOVE.B   #$39,(A1)+
    MOVE.B   #$30,(A1)+
    SUB.L    #1,D6
    CMP      #0,D6
    BNE      BUC1
    MOVE.B   #$0d,(A1)+
    SUB.L    #1,D5
    CMP      #0,D5
    BNE      BUC2 
    
    MOVE.L   #0,D5  
    MOVE.L   #BUFFER,A1
BUC3:
    CMP      #3,D5
    BEQ      RETRET
    MOVE.W   #1001,D4
BUC4:    
    MOVE.W   D4,-(A7)
    MOVE.W   D3,-(A7)
    MOVE.L   A1,-(A7)
    BSR PRINT
    MOVE.L   (A7)+,A1
    MOVE.W   (A7)+,D3
    MOVE.W   (A7)+,D4
    SUB.L    D0,D4
    ADD.L    D0,A1
    CMP      #0,D4
    BNE      BUC4
    ADD.L    #1,D5
    JMP      BUC3
        
  RETRET:
    nop
    nop
    nop
    nop
    nop
    nop
    JMP RETRET


        
**************************** FIN PRUEBAS ******************************************************
        
****************************** INICIO DE GATITOS ASCII ****************************************
*                                                                                             *
*                                                                                             *
*                                     __..--''``---....___   _..._    __                      *
*                  /// //_.-'    .-/";  `        ``<._  ``.''_ `. / // /                      *
*                 ///_.-' _..--.'_    \                    `( ) ) // //                       *
*                 / (_..-' // (< _     ;_..__               ; `' / ///                        *
*                  / // // //  `-._,_)' // / ``--...____..-' /// / //                         *
*                                                                                             *
*        Kitty cat :D                                                                         *
*                                                                                             *
*                 __..--''``\--....___   _..,_                                                *
*              _.-'    .-/";  `        ``<._  ``-+'~=.                                        *
*          _.-' _..--.'_    \                    `(^) )                                       *
*         ((..-'    (< _     ;_..__               ; `'                                        *
*                    `-._,_)'      ``--...____..-'                                            *
*                                                                                             *
*                                                                                             *
*                                  _,'|             _.-''``-...___..--';)                     *
*                                  /_ \'.      __..-' ,      ,--...--'''                      *
*                                 <\    .`--'''       `     /'                                *
*                                  `-';'               ;   ; ;                                *
*                            __...--''     ___...--_..'  .;.'                                 *
*                           (,__....----'''       (,..--''                                    *
*                                                                                             *
******************************** FIN DE GATITOS ASCII *****************************************        
