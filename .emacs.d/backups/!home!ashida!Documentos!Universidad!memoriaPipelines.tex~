% Created 2016-05-06 vie 15:38
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\author{Roberto Sarmiento del Río (u120233),\\ Alberto Revuelta Arribas (u120001)}
\date{\today}
\title{\text{120001\_120233\_Sesion2}}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.5.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\tableofcontents


\section{Sesion 1}
\label{sec-1}
\subsection{Dependencias existentes en el programa original, sin AD y con AD.}
\label{sec-1-1}
\begin{description}
\item[{Tipo}] DD: Dependencias de Datos DC: Dependencias de Control
\item[{Instrucciones}] Número correspondiente a las intrucciones que
producen la dependencia
\item[{Registros}] Registros que se ven afectados en las dependencias.
\item[{Parones}] NOP's del programa
\item[{Veces}] Cuantas veces se repite la dependencia
\item[{ToT}] Cuantas veces en el programa entero
\item[{Parones con AD}] Parones con ADelantamientos activados
\item[{Tipos de AD}] Tipos de ADelantamiento
\end{description}
\begin{center}
\begin{tabular}{|c|ccccc|cc|}
\hline
Tipo & Instrucciones & Registros & Parones & Veces & ToT & Parones con AD & Tipos de AD\\
\hline
DD & 14-15 & R14 & 2 & 8 & 16 & 0 & ALU-ALU\\
\hline
DD & 15-16 & R15 & 2 & 64 & 128 & 0 & ALU-ALU\\
\hline
DD & 16-17 & R15 & 2 & 64 & 128 & 1(64) & MEM-ALU\\
\hline
DC & 17 & PC & 3 & 64 & 192 & 3 & -\\
\hline
DD & 18-19 & R9 & 2 & 42 & 84 & 0 & ALU-ALU\\
\hline
DD & 19-20 & R17 & 2 & 42 & 84 & 0 & ALU-ALU\\
\hline
3 & 21-22 & R17 & 2 & 42 & 84 & 0 & ALU-ALU\\
\hline
DD & 24-26 & R22 & 0 & 42 & 84 & 0 & ALU-ALU\\
\hline
DD & 25-26 & R23 & 2 & 42 & 84 & 0 & ALU-ALU\\
\hline
DD & 27-28 & R24 & 2 & 64 & 128 & 1(64) & MEM-ALU\\
\hline
DD & 29-30 & R25 & 2 & 64 & 128 & 0 & ALU-ALU\\
\hline
DD & 31-33 & R4 & 1 & 64 & 128 & 0 & ALU-ALU\\
\hline
DD & 33-34 & R26 & 2 & 64 & 128 & 0 & ALU-ALU\\
\hline
DC & 34 & PC & 3 & 64 & 128 & 3(192) & -\\
\hline
DD & 35-36 & R18 & 2 & 8 & 16 & 0 & ALU-ALU\\
\hline
DD & 37-39 & R2 & 1 & 8 & 16 & 0 & ALU-ALU\\
\hline
DD & 39-40 & R26 & 2 & 8 & 16 & 0 & ALU-ALU\\
\hline
DD & 40 & PC & 3 & 8 & 16 & 3(24) & -\\
\hline
\end{tabular}
\end{center}
Tenemos por lo general que se generan 2 parones, esto significa que el
procesador ha realizado dos operaciones NOP para esperar a que termine
la isntrucción antes de ejecutar la siguiente. En el caso de tener 3
parones, significa que a parte de esperar la terminación, necesitamos
esperar la modificación del PC, esto suele darse en instrucciones de
salto.
Hemos detectado, además, una dependencia en las lineas 24-26 pero al
tener en la siguiente linea otra dependencia, esta es ignorada.
\begin{equation}
CPI = {{\text{nº de ciclos} - 4}\over{\text{nº instrucciones útiles}}} = 
\frac{2809-4}{1173} = 2.39
\end{equation}
\subsubsection{Sin adelantamiento}
\label{sec-1-1-1}
\begin{equation}\begin{split}
DC = 192+192+24 = 408 \text{ ciclos } \frac{408}{1632} $\rightarrow$ 25\\
DD = 1224 \text{ ciclos } \frac{1224}{1632} $\rightarrow$ 75
\end{split}\end{equation}
\subsubsection{Con adelantamiento}
\label{sec-1-1-2}
\begin{equation}\begin{split}
DD = \frac{408}{336} $\rightarrow$ 76.1 \% \\
DC = \frac{128}{336} $\rightarrow$ 23.9 \% \\
CPI = \frac{2809}{1713} = 1.64 
\end{split}\end{equation}
\subsection{Reordenación de código}
\label{sec-1-2}
Teníamos mal pensado los cambios enviados en la entrega anterior, 
para mejorar el programa realizamos una modificación entre las lineas 16 y 17 y añadimos 2
lineas que no dependan de los registros usados hasta el momento. En
este caso sería la 27.
\begin{verbatim}
add r6, r10, r14        ; (15) dir de mA 
lw r15, 0(r6)           ; (16) leer mA(i,j)
add r24, r21, r14       ; (27) dir de mC CAMBIO
beqz r15, cero          ; (17)
sll r9, r1, #2          ; (18) k*4
\end{verbatim}
Tambien entre la 28 y la 29 colocamos la 3 para optimizar el paron
realizado en esa zona.
\begin{verbatim}
lw r25, 0(r24)          ; (28) leer mC
add r4, r4, #1          ; (31) j++ CAMBIO
sll r25, r25, #1        ; (29) mC*20
\end{verbatim}
\section{Sesion 2}
\label{sec-2}
\subsection{Con 1 delay slot}
\label{sec-2-1}
Entre la linea 33-34, introducimos la linea 32.
Entre la linea 34-37, introducimos la linea 30.
Entre la linea 39-40, introducimos la linea 35.
Entre la linea 40-41, introducimos la linea 36.
\begin{verbatim}
start:
        add r10, r0, mA         ; direccion de comienzo de mA
        add r11, r0, sumf       ; direccion de comienzo de sumf
        add r12, r0, fil        ; direccion de comienzo de fil
        add r13, r0, col        ; direccion de comienzo de col
        add r20, r0, mB         ; direccion de comienzo de mB
        add r21, r0, mC         ; direccion de comienzo de mC
;
        or r27, r0, #255        ; masc = 255
        or r1, r0, r0           ; k = 0
        or r2, r0, r0           ; i = 0
        or r3, r0, r0           ; direccion relativa de comienzo de fila de mat
uni:
        or r7, r0, r0           ; (11) aux = 0
        or r4, r0, r0           ; (12) j = 0
        sll r5, r2, #2          ; (13) i*4
        or r14, r0, r3          ; (14) dir. relativa siguiente elto. de mat

unj:
        add r6, r10, r14        ; (15) dir de mA
        lw r15, 0(r6)           ; (16) leer mA(i,j)
        add r24, r21, r14       ; (27) dir de mC CAMBIO
        lw r25, 0(r24)          ; (28) leer mC CAMBIO
; 1 paron !!!!
        beqz r15, cero          ; (17)
        sll r25, r25, #1        ; (29) mC*20 CAMBIO
        sll r9, r1, #2          ; (18) k*4
        add r17, r12, r9        ; (19)
        sw 0(r17), r2           ; (20) fil(k) = i
        add r17, r13, r9        ; (21)
        sw 0(r17), r4           ; (22) col(k) = j
        add r1, r1, #1          ; (23) k++
        and r22, r15, r27       ; (24) mA && masc
        add r23, r20, r14       ; (25) dir de mB 
        sw 0(r23), r22          ; (26) mB = mA && masc
cero:
        add r4, r4, #1          ; (31) j++ 
        sLT r26, r4, #8         ; (33)
        add r14, r14, #4        ; (32) avanzar un elemento en mats CAMBIO
; * 1 paron
        bnez r26, unj           ; (34)
        add r7, r7, r25         ; (30) aux+= mC*2 CAMBIO
        add r2, r2, #1          ; (37) i++
        add r3, r3, #32         ; (38) avanzar una fila en mats
        sLT r26, r2, #8         ; (39)
        add r18, r11, r5        ; (35) dir de sumf CAMBIO
; * 1 paron
        bnez r26, uni           ; (40)
        sw 0(r18), r7           ; (36) sumf(i) = aux; CAMBIO
        trap 0                  ; (41)
\end{verbatim}

\begin{equation}\begin{split}
CPI = \frac{1449-4}{1173}=1,23\\
\text{Ganancia: }\frac{1713}{1449}=1,1\\
\text{Reordenado:}\\
CPI = \frac{1177-4}{1173}=1,22\\
\text{Ganancia: }\frac{1585}{1177}=1,35
\end{split}\end{equation}
\subsection{Con predicción de no salto}
\label{sec-2-2}
  Deja introducir instrucciones después del salto, si se cumple no se
realizan, mientras que si no ya se han adelantado.
\begin{equation}\begin{split}
CPI = \frac{1432-4}{1173}\\
\text{Ganancia: }\frac{1585}{1447}=1,11
\end{split}\end{equation}
\subsection{Con predicción dinámica de 1 o 2 bits}
\label{sec-2-3}
   Se pierden en caso de que no se realicen 2 ciclos. Gracias a esta
estrategia de salto ganamos en ciclos al ejecutar el programa. 
Sedeben a los fallos de predicción del simulador. 
Con 2 bits se reducen un poco más los ciclos realizados.
Lo mejor es el delay slot 1, pero con esto el programador tiene que
realizar un gran esfuerzo para optimizar el código. 
Es más dificil hoy en día ya que las etapas que tiene un procesador
son mucho mayores y siempre se le pueden escapar en algún sitio.
% Emacs 24.5.1 (Org mode 8.2.10)
\end{document}
