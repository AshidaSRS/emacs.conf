import bitstruct as bs
import bitarray as ba
import bitstring as bst
import matplotlib.pyplot as plt
import numpy as np
import random as rd
from binascii import unhexlify
from pygost import gost3411_94


def long_to_bytes (val, endianness='big'):
    """
    Use :ref:`string formatting` and :func:`~binascii.unhexlify` to
    convert ``val``, a :func:`long`, to a byte :func:`str`.

    :param long val: The value to pack

    :param str endianness: The endianness of the result. ``'big'`` for
      big-endian, ``'little'`` for little-endian.

    If you want byte- and word-ordering to differ, you're on your own.

    Using :ref:`string formatting` lets us use Python's C innards.
    """

    # one (1) hex digit per four (4) bits
    width = val.bit_length()

    # unhexlify wants an even multiple of eight (8) bits, but we don't
    # want more digits than we need (hence the ternary-ish 'or')
    width += 8 - ((width % 8) or 8)

    # format width specifier: four (4) bits per hex digit
    fmt = '%%0%dx' % (width // 4)

    # prepend zero (0) to the width, to zero-pad the output
    s = unhexlify(fmt % val)

    if endianness == 'little':
        # see http://stackoverflow.com/a/931095/309233
        s = s[::-1]

    return s




def paramEntry(text):
    data = text.encode('UTF-8')
    hashEntry = gost3411_94.new(data)
    hashDataB = hashEntry.digest()
    hashDataH = hashEntry.hexdigest()
    print("Text:")
    print(text)
    print("\nHash in bytes:")
    print( hashDataB)
    print("\nHash in hex:")
    print( hashDataH)

def testing():
        pos = [0, 1]
        n = 1
       
        res = list()
        while(n < 20):
            suma = 0
            for x in  pos:
                ref_hash = int.from_bytes(gost3411_94.new(bytes(x)).digest(), byteorder = "little")
                print("ref_hash: " + str(ref_hash))
                for i in range(0, n):
                    test_hash = int.from_bytes(gost3411_94.new(bytes(x^(1 << i))).digest(), byteorder= "little")
                    print("test_hash: " + str(test_hash))
                    for j in range(0, n):
                        res.append(((ref_hash  ^  test_hash) >> j) & 1)
            print("res:" + str(res))
            print("Len(res): "+ str(len(res)))
            for k in res:
                if (k == 1): suma = suma + 1
                #print(str(k /(n * 2**n)))
            n = n+1
            print("suma: " + str(suma))
            res = list()


def testing2():
    bateria_resultados = list()
    err_rel_media = 1
    err_rel_var = 1
    media = 256*0.5
    varianza = media * 0.5
    while((err_rel_media > 0.1) & (err_rel_var > 0.1)):
        i = 0
        print("IteracciÃ³n: "+ str(i))
        while(ns > 0):
            num = rd.randint(0,2**256)
            mask = rd.randint(0,255)
            num_with_mask = 0
            num_with_mask ^= (1 << 256 -1 -mask )
        
            numBytes = long_to_bytes(num)
            numMaskBytes = long_to_bytes(num_with_mask)
            #print("Antes: " + str(num))
            #print("Despues: " + str(num_with_mask))
            #print("Resta: " + str(num - num_with_mask) )
        
            X = int.from_bytes(gost3411_94.new(bytes(numBytes)).digest(), byteorder="big")  ^  int.from_bytes(gost3411_94.new(bytes(numMaskBytes)).digest(), byteorder="big")
            #print("x: " + str(X))
        
            setByteX = bin(X).count("1")
        
            #print("set bytes of X:  " + str(setByteX))
        
            ksac = setByteX/256
        
            #print("Ksac: " + str(ksac))
            #ns = ns -1 
            
            bateria_resultados.append(ksac)
        i = i + 1
    media_ex = float(sum(bateria_resultados)/(len(bateria_resultados)))
    varianza_ex = media * 0.5
    error_rel_media =abs((media-media_ex)/media)
    error_rel_var = abs((varianza- varianza_ex)/varianza)
    print("media: "+ str(media))
    print("error_rel_media: " + str(err_rel_media))
    print("error_rel_varianza: " + str(error_rel_varianza))

    freq = list()
    bat = sorted(bateria_resultados)
    for i in bat:
        freq.append(bat.count(i))

    plt.plot( bat, freq)
    plt.show()
    
if __name__ == "__main__":
    text = "Holo"
    #paramEntry(text)
    #testing()
    testing2()

